package RBNLearning;

import java.util.*;
import java.io.*;
import RBNpackage.*;
import RBNgui.*;
import RBNExceptions.*;
import RBNutilities.*;
import RBNinference.*;



/** In a GradientGraphConvCombNode the children vector has exactly
 *  3 elements, one for each of the three subformulas
 *  An element is set to null if the formula  does not actually
 *  need to be contained in this vector.
 */
public class GradientGraphConvCombNode extends GradientGraphProbFormNode{
    

    double[] evalOfSubPFs;


    /** pf must be a ground ProbForm ! */
    public GradientGraphConvCombNode(GradientGraph gg,
				     ProbForm pf, 
				     Hashtable allnodes, 
				     RelStruc A, 
				     Instantiation data)
	throws RBNCompatibilityException
    {
	super(gg,pf,A,data);
	evalOfSubPFs = new double[3];
	for (int i = 0; i<3; i++){
	    evalOfSubPFs[i]= ((ProbFormConvComb)pf).subPF(i+1).evaluate(A, 
									data , 
									new String[0], 
									new int[0] , 
									false);
	}


	children = new Vector<GradientGraphProbFormNode>();
	for (int i = 0; i<3; i++){
	    /*TODO: this does not utilize that e.g. F2 is not needed when F0=1 */
	    if (evalOfSubPFs[i] == -1)
		children.add(GradientGraphProbFormNode.constructGGPFN(gg,
								      ((ProbFormConvComb)pf).subPF(i+1),
								      allnodes, 
								      A, 
								      data));
	    else
		children.add(null);
	}

	if (!(pf instanceof ProbFormConvComb)){
	    System.out.println("Cannot create GradientGraphConvCombNode from ProbForm " + pf.asString());
	}
    }




    public double evaluate(){
	//System.out.println("evaluate convcomb " + rbnutilities.arrayToString(evalOfSubPFs));
	if (value != null) {
	    //System.out.println("evaluate in Conv Comb 1: "  + (double)value);
	    return (double)value;
	}
	double result = 0;
	GradientGraphProbFormNode F0 = children.elementAt(0);
	GradientGraphProbFormNode F1 = children.elementAt(1);
	GradientGraphProbFormNode F2 = children.elementAt(2);
	/* F0F1: */
	if (F0 != null)
	    if (F1 != null)
		result = result + F0.evaluate()*F1.evaluate();
	    else 
		if (evalOfSubPFs[1] != 0)
		    result = result + F0.evaluate()*evalOfSubPFs[1];
		else;
	else
	    if (evalOfSubPFs[0] != 0)
		if (F1 != null)
		    result = result + evalOfSubPFs[0]*F1.evaluate();
		else result = result + evalOfSubPFs[0]*evalOfSubPFs[1];
	/* -F0F2: */
	if (F0 != null)
	    if (F2 != null)
		result = result - F0.evaluate()*F2.evaluate();
	    else 
		if (evalOfSubPFs[2] != 0)
		    result = result - F0.evaluate()*evalOfSubPFs[2];
		else;
	else
	    if (evalOfSubPFs[0] != 0)
		if (F2 != null)
		    result = result - evalOfSubPFs[0]*F2.evaluate();
		else result = result - evalOfSubPFs[0]*evalOfSubPFs[2];
	/* +F2: */
	if (F2 != null)
	    result = result + F2.evaluate();
	else 
	    result = result + evalOfSubPFs[2];
	    
	value = result;
	if (result == Double.NaN)
	    System.out.println("result in evaluate for conv.comb " + this.name() +" : " + result);
	return result;
    }



    public void evaluateBounds(){
	if (bounds[0]==-1){ /* Not yet evaluated for current indicator setting */
	    //	    System.out.println("convcombnode.evaluateBounds");
	    GradientGraphProbFormNode F0 = children.elementAt(0);
	    GradientGraphProbFormNode F1 = children.elementAt(1);
	    GradientGraphProbFormNode F2 = children.elementAt(2);
	    double lowF0;
	    double uppF0;
	    double lowF1;
	    double uppF1;
	    double lowF2;
	    double uppF2;
	    if (F0!=null){
		F0.evaluateBounds();
		lowF0=F0.lowerBound();
		uppF0=F0.upperBound();
	    }
	    else{
		lowF0=evalOfSubPFs[0];
		uppF0=evalOfSubPFs[0];
	    }
	    if (F1!=null){
		F1.evaluateBounds();
		lowF1=F1.lowerBound();
		uppF1=F1.upperBound();
	    }
	    else{
		lowF1=evalOfSubPFs[1];
		uppF1=evalOfSubPFs[1];
	    }
	    if (F2!=null){
		F2.evaluateBounds();
		lowF2=F2.lowerBound();
		uppF2=F2.upperBound();
	    }
	    else{
		lowF2=evalOfSubPFs[2];
		uppF2=evalOfSubPFs[2];
	    }
	    /* Find lower bound. The bound is not necessarily achievable,
	     * since the bounds on 3 sub-formulas may not be independently
	     * achievable
	     */
	    if (lowF1 > lowF2)
		bounds[0]=lowF0*lowF1 + (1-lowF0)*lowF2;
	    else
		bounds[0]=uppF0*lowF1 + (1-uppF0)*lowF2;
	    /* Similar for the upper bound */
	    if (uppF1 > uppF2)
		bounds[1]=uppF0*uppF1 + (1-uppF0)*uppF2;
	    else
		bounds[1]=lowF0*uppF1 + (1-lowF0)*uppF2;
	}
    }

    public double evaluateGrad(int param){
	if (gradient[param] != null) 
	    return (double)gradient[param];
	if (!dependsOnParam[param])
	    return 0.0;
	double result = 0;
	GradientGraphProbFormNode F0 = children.elementAt(0);
	GradientGraphProbFormNode F1 = children.elementAt(1);
	GradientGraphProbFormNode F2 = children.elementAt(2);


	/* F0'F1: */
	if (F0 != null){
	    if (F0.dependsOn(param)){
		if (F1 != null)
		    result = result + F0.evaluateGrad(param)*F1.evaluate();
		else 
		    result = result + F0.evaluateGrad(param)*evalOfSubPFs[1];
	    }
	}
	/* +F0F1': */
	if (F1 != null){
	    if (F1.dependsOn(param)){
		if (F0 != null)
		    result = result + F1.evaluateGrad(param)*F0.evaluate();
		else 
		    result = result + F1.evaluateGrad(param)*evalOfSubPFs[0];
	    }
	}
	/* -F0'F2: */
	if (F0 != null){
	    if (F0.dependsOn(param)){
		if (F2 != null)
		    result = result - F0.evaluateGrad(param)*F2.evaluate();
		else
		    result = result - F0.evaluateGrad(param)*evalOfSubPFs[2];
	    }
	}
	/* -F0F2': */
	if (F2 != null){
	    if (F2.dependsOn(param)){
		if (F0 != null)
		    result = result - F2.evaluateGrad(param)*F0.evaluate();
		else
		    result = result - F2.evaluateGrad(param)*evalOfSubPFs[0];
	    }
	}
	/* +F2' */
	if (F2 != null && F2.dependsOn(param))
	    result = result + F2.evaluateGrad(param);
	
	gradient[param] = result;
	return result;
    }




}
