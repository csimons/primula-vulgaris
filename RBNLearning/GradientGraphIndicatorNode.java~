package RBNLearning;

import java.util.*;
import java.io.*;
import RBNpackage.*;
import RBNgui.*;
import RBNExceptions.*;
import RBNutilities.*;
import RBNinference.*;


public class GradientGraphIndicatorNode extends GradientGraphProbFormNode{
    
    /** Ground atom represented by this node */
    Atom myatom;
    
//     /** Set to 1 if the ground atom is instantiated to true in the data,
//      * to 0 if ground atom false in data, to -1 if value for this ground
//      * atom is missing in the data (GradientGraphIndicatorNodes with instValInData != -1 
//      * may never need to be constructed!).
//      */
//     int instValInData;


/** The current instantiation for this indicator;
 * currentInst = -1 if not currently instantiated
 */
    int currentInst;


//     /** The node in this GradientGraph that contains the probability formula
//      * defining the probability for this ground atom
//      */
//     GradientGraphProbFormNode mypf;

    /** Represents a current value for this Node in EM procedure
     * Only needed when instValInData = -1
     */
    boolean[] sampledVals;

    public GradientGraphIndicatorNode(GradientGraph gg,
				      ProbForm pf,  
				      RelStruc A,
				      Instantiation data)
	throws RuntimeException, RBNCompatibilityException
    {
	super(gg,pf,A,data);
	currentInst = -1;
// 	mypf = null;
// 	instValInData = data.truthValueOf(((ProbFormIndicator)pf).relation,((ProbFormIndicator)pf).argsIfGround());
	sampledVals = new boolean[0];
	if (!(pf instanceof ProbFormIndicator)){
	    System.out.println("Cannot create GradientGraphIndicatorNode from ProbForm " + pf.asString());
	}
	myatom = ((ProbFormIndicator)pf).atom();
	gg.addToIndicators(this);
	children = null;
    }



    public double evaluate(){
	return currentInst;
    }


    public void evaluateBounds(){
	switch(currentInst){
	case -1:
	    bounds[0]=0;
	    bounds[1]=1;
	    break;
	case 0:
	    bounds[0]=0;
	    bounds[1]=0;
	    break;
	case 1:
	    bounds[0]=1;
	    bounds[1]=1;
	    break;
	}
    }

    public double evaluateGrad(int param){
	return 0.0;
    }

    public Atom myatom(){
	return myatom;
    }

//     public boolean mypfIsNull(){
// 	if (mypf == null)
// 	    return true;
// 	else
// 	    return false;
//     }

//     public void sampleVals(int size){
// 	sampledVals = new boolean[size];
// 	double rand;
// 	for (int i=0;i<size;i++){
// 	    rand = Math.random();
// 	    if (rand >0.5)
// 		sampledVals[i]=false;
// 	    else
// 		sampledVals[i]=true;
// 	}
//     }

    /** Sets the current instantiation according to 
     * the value in the sno's sample
     */
    public void setCurrentInst(int sno){
	if (sampledVals[sno])
	    currentInst = 1;
	else
	    currentInst = 0;
    }

    /** Sets value in sno's sample to tv */
    public void setSampleVal(int sno, boolean tv){
	sampledVals[sno]=tv;
    }

    /** Sets the current instantiation according to 
     * the truth value tv
     */
    public void setCurrentInst(boolean tv){
	if (tv)
	    currentInst = 1;
	else
	    currentInst = 0;
    }

    public int getCurrentInst(){
	return currentInst;
    }

//     public void setMypf(GradientGraphProbFormNode ggpfn){
// 	mypf = ggpfn;
//     }

    /** initializes  sampledVals to an array of size 'size' */
    public void initSampledVals(int size,int samplemode){
	switch (samplemode){
	case 0: 
	    sampledVals = new boolean[size];
	    break;
	case 1: 
	    int oldsize = sampledVals.length;
	    boolean[] newSampledVals = new boolean[oldsize+size];
	    for (int i=0;i<oldsize;i++)
		newSampledVals[i]=sampledVals[i];
	    sampledVals=newSampledVals;
	    break;
	case 2:
	    break;
	}
    }

//     public void setTruthValAtMypf(int sno){
// 	if (sampledVals[sno])
// 	    mypf.setTruthVal(1);
// 	else
// 	    mypf.setTruthVal(0);
//     }

    /** Resets the currentInst field to -1, i.e. node 
     * becomes un-instantiated
     */
    public void unset(){
	currentInst = -1;
    }
}
