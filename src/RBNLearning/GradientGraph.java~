package RBNLearning;

import java.util.*;
import java.io.*;
import RBNpackage.*;
import RBNgui.*;
import RBNExceptions.*;
import RBNutilities.*;
import RBNinference.*;

public class GradientGraph{
    
    private Primula myPrimula;

    private Hashtable allNodes;

    private CombFuncNOr combFuncNOr;
    private CombFuncMean combFuncMean;
    private CombFuncInvsum combFuncInvsum;
    private CombFuncESum combFuncESum;
    

    GradientGraphLikelihoodNode llnode;
    Vector<GradientGraphIndicatorNode> indicators; /* All the indicators for unknown atoms */
    Vector<GradientGraphConstantNode> paramNodes; /* All the constant (i.e. parameter) nodes */
    
 
    String[] parameters; /* All the parameters. This array of parameter names is constructed
			  * before the vector paramNodes is constructed. It is needed already
			  * in the construction of the nodes of the graph. The order of the 
			  * two lists of parameters must be consistent, i.e.
			  * parameters[i] = paramNodes.elementAt(i).paramname() 
			  */

    int samplecount;

    /** Array of size samplecount. Stores 1/(sampling probability) of the 
     * samples. Set to -1 when a sample was aborted 
     */
    double[] sampleProbs = new double[0]; 


    public GradientGraph(RBN rbn,RelStruc A,Instantiation data)
	throws RBNCompatibilityException
    {
	allNodes = new Hashtable();
	combFuncNOr = new CombFuncNOr();
	combFuncMean = new CombFuncMean();
	combFuncInvsum = new CombFuncInvsum();
	combFuncESum = new CombFuncESum();
	
	indicators = new Vector<GradientGraphIndicatorNode>();
	samplecount = 0;
	/* Determine number of parameters. This is needed when constructing the nodes */
	parameters = new String[0];
	ProbForm nextpf;
	if (rbn==null) System.out.println("rbn is null");
	for (int i=0; i<rbn.NumPFs(); i++){
	    nextpf = rbn.ProbFormAt(i);
	    parameters = rbnutilities.arraymerge(parameters,nextpf.parameters());
	}

	llnode = new GradientGraphLikelihoodNode(this);
	/* Create all the ground probability formulas for the atoms in data 
	 *  
	 */
	Rel nextrel;
	Vector inrel;
	String[] vars; /* The argument list for nextpf */
	ProbForm groundnextpf;

 	GradientGraphProbFormNode fnode;

	double pfeval;
	for (int i=0; i<rbn.NumPFs(); i++){

	    nextpf = rbn.ProbFormAt(i);
	    vars = rbn.argumentsAt(i);
	    nextrel = rbn.relAt(i);
	    for (int ti = 0; ti <= 1 ; ti++) {

		if (ti == 0)
		    inrel = data.allFalse(nextrel);
		else
		    inrel = data.allTrue(nextrel);
		for (int j=0;j<inrel.size();j++){
		    groundnextpf = nextpf.substitute(vars,(int[])inrel.elementAt(j));
		    pfeval = groundnextpf.evaluate(A,data,new String[0],new int[0],false);

		    if (pfeval == -1){
			/* if pfeval != -1, then this groundnextpf has a constant value
			 * independent of parameter settings or instantiation of unknown
			 * atoms. For a correct numeric value of the likelihood this value
			 * would need to be considered, but for maximizing the likelihood
			 * it is irrelevant
			 */
			fnode = GradientGraphProbFormNode.constructGGPFN(this,
									 groundnextpf,
									 allNodes,
									 A,									 						 data);
			if (ti==0)			
			    llnode.addToChildren(fnode,false);
			else
			    llnode.addToChildren(fnode,true);
		    }
		    System.out.print(".");
		}
	    }/* for  truefalse  */
	    System.out.println();
	}
	
	/* Construct ProbFormNodes for all Indicator nodes,
	 * and set the mypf fields in the indicator nodes
	 */

	/* lastindicator is the index of the last indicator
	 * node for which a ProbFormNode has already been
	 * constructed
	 */
	int lastindicator = -1;
	Atom at;
	GradientGraphIndicatorNode nextggin;
	int[] nextarg;
	while (indicators.size() - lastindicator -1 >0){
	    lastindicator++;
	    nextggin = indicators.elementAt(lastindicator);
	    at = nextggin.myatom();
	    nextarg = at.args();
	    nextpf = rbn.probForm(at.rel());
	    vars = rbn.args(at.rel());
	    groundnextpf = nextpf.substitute(vars,nextarg);
	    /** Note that (arbitrarily) the truthval of the constructed
	     * node is set to true. This initial setting must always be overridden
	     * by some sample value for this node
	     */
	    fnode =  GradientGraphProbFormNode.constructGGPFN(this,
							      groundnextpf,
							      allNodes,
							      A,
							      data);
	    llnode.addToChildren(fnode,nextggin);
	}




	/* Now bring the parameter nodes into the right order: 
	 * TODO: it could happen that for some parameter no parameter node
	 * has been constructed (because no atom in the data actually depended 
	 * on this parameter)  -- still needs to be dealt with!!!
	 */
	Vector<GradientGraphConstantNode> prelimParamNodes = new Vector<GradientGraphConstantNode>();
	Enumeration e = allNodes.elements();
	GradientGraphNode nextggn;
	while (e.hasMoreElements()){
	    nextggn = (GradientGraphNode)e.nextElement();
	    if (nextggn instanceof GradientGraphConstantNode)
		prelimParamNodes.add((GradientGraphConstantNode)nextggn);
	}
	for (int i=0; i< prelimParamNodes.size(); i++)
	    System.out.println("prelim param nodes: " + ((GradientGraphConstantNode)prelimParamNodes.elementAt(i)).name());
	paramNodes = new Vector<GradientGraphConstantNode>();
	boolean found;
	for (int i=0; i< parameters.length; i++){
	    System.out.print("node for " + parameters[i] + " .... ");
	    found = false;
	    for (int j=0; j< prelimParamNodes.size(); j++)
		if (((GradientGraphConstantNode)prelimParamNodes.elementAt(j)).paramname().equals(parameters[i])){
		    paramNodes.add((GradientGraphConstantNode)prelimParamNodes.elementAt(j));
		    found = true;
		    System.out.println("found");
		}
	    if (!found)
		paramNodes.add(null);
	}
	for (int i=0; i< paramNodes.size(); i++){
	    if (paramNodes.elementAt(i)!=null)
		System.out.println("param nodes: " + ((GradientGraphConstantNode)paramNodes.elementAt(i)).name());
	    else
		System.out.println("null"); 
	}
	System.out.println("indicators have size " +indicators.size());
    }

 
    protected void addToIndicators(GradientGraphIndicatorNode ggin){
	indicators.add(ggin);
    }

    protected double computeCombFunc(int cf, double[] args){
	switch (cf){
	case Primula.CF_NOR:
	    return combFuncNOr.evaluate(args);
	case Primula.CF_MEAN:
	    return combFuncMean.evaluate(args);
	case Primula.CF_INVSUM:
	    return combFuncInvsum.evaluate(args);
	case Primula.CF_ESUM:
	    return combFuncESum.evaluate(args);
	}
	return 0;
    }

    public double[] currentLikelihood(){
	return llnode.likelihood();
    }



    public double[] currentParameters(){
	double[] result = new double[paramNodes.size()];
	for (int i=0;i<paramNodes.size();i++){
	    if (paramNodes.elementAt(i)!= null)
		result[i]=paramNodes.elementAt(i).value();
	    else result[i] = 0.5;
	}
	return result;
    }

    //     public void evaluate(int sno){
    // 	evaluateLikelihood(sno);
    //     }

    public int numberOfParameters(){
	return parameters.length;
    }

    public String[] parameters(){
	return parameters;
    }

    public String parameterAt(int i){
	return parameters[i];
    }

    //     public void updateAll(){
    // 	updateLikelihood();
    // 	updatePartDerivatives();
    //     }


    /** Computes the empirical likelihood and empirical partial derivatives 
     * of the current sample.
     * The value and gradient fields contain the values for the last sample.
     *
     * When samplesize=0, then value = likelihoodsum and gradient = gradientsum 
     * are the correct values.
     *
     */ 
    public void evaluateLikelihoodAndPartDerivs(boolean likelihoodonly){
	resetValues(likelihoodonly);
	llnode.resetSampleValue();
	if (!likelihoodonly){
	    llnode.resetSampleGradient();
	}

	if (samplecount==0){
	    llnode.evaluate();
	    llnode.updateLikelihood(1);
	    if (!likelihoodonly){
		llnode.evaluateGradients();
		llnode.updateGrad(1);
	    }
	}
	else{
	    for (int i=0;i<samplecount;i++){
		if (sampleProbs[i]!=-1){
		    resetValues(likelihoodonly);
		    setTruthVals(i);
		    // System.out.println("params: " + rbnutilities.arrayToString(getParameters()));
		    // 		    System.out.print("< ");
		    llnode.evaluate();
		    //System.out.println(rbnutilities.arrayToString(llnode.likelihood())+ "> ");
		    llnode.setSampleLikelihood(i);
		    llnode.updateLikelihood(sampleProbs[i]);
		    if (!likelihoodonly){
			llnode.evaluateGradients();
			llnode.updateGrad(sampleProbs[i]);
		    }
		}
	    }
	}
    }




    public void evaluateBounds(){
	llnode.evaluateBounds();
    }


    /* Resets to null the value fields in nodes in this GradientGraph. 
     * If nonpartderivonly=true, then only GradientGraphProbFormNodes with
     * isPartDeriv=false (as collected in nonDerivatives) are reset */
    public void resetValues(boolean nongradonly){
	llnode.resetValue();
	if (!nongradonly)
	    llnode.resetGradient();
	Enumeration e = allNodes.elements();
	GradientGraphNode ggn;
	while (e.hasMoreElements()){
	    ggn = (GradientGraphNode)e.nextElement();
	    ggn.resetValue();
	    if (!nongradonly)
		ggn.resetGradient();
	}	
    }

    /** Resets to [-1,-1] the bounds in all nodes */
    public void resetBounds(){
	llnode.resetBounds();
	Enumeration e = allNodes.elements();
	GradientGraphProbFormNode ggn;
	while (e.hasMoreElements()){
	    ggn = (GradientGraphProbFormNode)e.nextElement();
	    ggn.resetBounds();
	}
    }

    public void resetSamplePartDerivs(){
	llnode.resetSampleGradient();
    }



    
    //     /** Tries to sample 'size' instantiations of the indicators. Returns
    //      * true if at least successrate*size samples were successful
    //      */
    //     public boolean sampleIndicators(int size,double successrate){
    // 	double[] lowtr;
    // 	double[] upptr;
    // 	double[] lowfal;
    // 	double[] uppfal;

    // 	boolean abort;
    // 	double trueprob;
    // 	double coin;
    // 	double[] midtr;
    // 	double[] midfal;

    // 	int abortcount=0;

    // 	for (int i=0;i<indicators.size();i++)
    // 	    indicators.elementAt(i).initSampledVals(size);
    // 	sampleProbs=new double[size];
	
    // 	for (int k=0;k<size;k++){
    // 	    sampleProbs[k]=1;
    // 	    abort = false;
    // 	    for (int i=0;i<indicators.size() && !abort;i++){
    // 		indicators.elementAt(i).setCurrentInst(true);
    // 		evaluateBounds();
    // 		lowtr = llnode.lowerBound();
    // 		upptr = llnode.upperBound();
    // 		resetBounds();
    // 		indicators.elementAt(i).setCurrentInst(false);
    // 		evaluateBounds();
    // 		lowfal = llnode.lowerBound();
    // 		uppfal = llnode.upperBound();
    // 		resetBounds();
    // 		//System.out.println("low/up false: " + lowfal + "," +uppfal +"  low/up true: " + lowtr+ "," +upptr); 
    // 		if (upptr[0] == 0 && uppfal[0] == 0){
    // 		    //System.out.println("Cannot find consistent sample");
    // 		    sampleProbs[k]=-1;
    // 		    abort = true;
    // 		}
    // 		if (upptr[0] == 0 && uppfal[0] > 0){
    // 		    indicators.elementAt(i).setSampleVal(k,false);
    // 		    //System.out.println("sample " + indicators.elementAt(i).name() + "= false with prob.1 " );
    // 		}
    // 		if (upptr[0] > 0 && uppfal[0] == 0){
    // 		    indicators.elementAt(i).setSampleVal(k,true);
    // 		    //System.out.println("sample " + indicators.elementAt(i).name() + "= true with prob.1 " );
    // 		}
    // 		if (upptr[0] > 0 && uppfal[0] > 0){
    // 		    /* Sample truth value with relative probabilities 
    // 		     * given by the midpoints between the upper and lower
    // 		     * bounds
    // 		     */
    // 		    midtr = SmallDouble.add(SmallDouble.multiply(upptr,05),SmallDouble.multiply(lowtr,0.5));
    // 		    midfal = SmallDouble.add(SmallDouble.multiply(uppfal,05),SmallDouble.multiply(lowfal,0.5));
    // 		    trueprob = SmallDouble.toStandardDouble(SmallDouble.divide(midtr,SmallDouble.add(midtr,midfal)));
    // 		    coin = Math.random();
    // 		    if (coin<trueprob){
    // 			indicators.elementAt(i).setSampleVal(k,true);
    // 			sampleProbs[k]=sampleProbs[k]*(1/trueprob);
    // 			//System.out.println("sample " + indicators.elementAt(i).name() + "= true with prob. " + trueprob );
    // 		    }
    // 		    else{
    // 			indicators.elementAt(i).setSampleVal(k,false);
    // 			sampleProbs[k]=sampleProbs[k]*(1/(1-trueprob));
    // 			//System.out.println("sample " + indicators.elementAt(i).name() + "= false with prob. 1-" + trueprob );
    // 		    }
    // 		}
    // 	    } /* for (int i=0;i<indicators.size() && !abort;i++) */
    // 	    if (abort) abortcount++;
    // 	}  /* for (int k=0;k<size;k++)*/
    // 	resetBounds();
    // 	unsetIndicators();
    // 	samplecount = size;
    // 	if (size>0 && abortcount/size > 1-successrate)
    // 	    return false;
    // 	else
    // 	    return true;
    //     }

 
    /** TODO: this method needs to be cleaned up! */
    /** samplemode = 0: replace old sample with new sample 
     *  samplemode = 1: add new sample to existing sample
     *  samplemode = 2: resample samples with low likelihood score
     *  samplemode = 3: do nothing
     *  samplemode = 4: MCMC resampling
     */
    public boolean sampleIndicators(int size,int maxfails,int samplemode){

	double coin;
	boolean abort = false;

	if (size > 0){
	    llnode.initSampleLikelihoods(size,samplemode);
	    for (int i=0;i<indicators.size();i++)
		indicators.elementAt(i).initSampledVals(size,samplemode);

	    int firstsampleindex=0;
	    switch (samplemode){
	    case 0: 
		sampleProbs=new double[size];
		firstsampleindex=0;
		samplecount=size;
		break;
	    case 1: 
		int oldsize = sampleProbs.length;
		double[] newsampleProbs = new double[oldsize+size];
		for (int i=0;i<oldsize;i++)
		    newsampleProbs[i]=sampleProbs[i];
		sampleProbs=newsampleProbs;
		firstsampleindex=oldsize;
		samplecount=oldsize+size;
		break;
	    case 2:    
		samplecount = size;
		break;
	    case 3:    
		samplecount = size;
		break;
	    case 4:    
		samplecount = size;
		break;
	    }

	    boolean success;
	
	    int failcount=0;
	
	    if (samplemode==0 || samplemode ==1){
		for (int k=0;k<size && !abort;k++){
		    success = false;
		    while (!success && !abort){
			sampleProbs[firstsampleindex+k]=1;
			for (int i=0;i<indicators.size();i++){
			    coin = Math.random();
			    if (coin>0.5)
				indicators.elementAt(i).setSampleVal(firstsampleindex+k,true);
			    else
				indicators.elementAt(i).setSampleVal(firstsampleindex+k,false);
			}
			resetValues(true);
			setTruthVals(firstsampleindex+k);
			llnode.evaluate();
			if (llnode.likelihood()[0]!=0)
			    success=true;   
			else{
			    failcount++;
			    if (failcount > maxfails)
				abort = true;
			    System.out.println("sample likelihood is zero!  " + rbnutilities.arrayToString(llnode.likelihood()));
			}
		    }
		}
	    }
	    if (samplemode==2){
		System.out.println("New sampling ****************");
		double[][] sliks = llnode.getSampleLikelihoods();
		double[][] sliks_sorted = sliks.clone();

		/* Find the median likelihood value */
		Arrays.sort((Object[])sliks_sorted,0,sliks_sorted.length,new SmallDoubleArrayComparatorByComponent(0,1));
		double[] median = sliks_sorted[(int)sliks_sorted.length/2];

		// 	    /* Compute the average sample likelihood: */
		// 	    double average[] = {0,0};
		// 	    for (int k=0;k<sliks.length;k++){
		// 		average = SmallDouble.add(average,sliks[k]);
		// 	    }

		// 	    //System.out.println(" average before division: " + rbnutilities.arrayToString(average));
		// 	    average = SmallDouble.multiply(average,(double)1/sliks.length);
		// 	    //System.out.println("sliks.length: " + sliks.length + " average: " + rbnutilities.arrayToString(average));

		/* Now resample all instantiations that have below average likelihood */
		for (int k=0;k<sliks.length;k++){
		    //System.out.println("sliks[k]: " + rbnutilities.arrayToString(sliks[k]));
		    if (SmallDouble.compareSD(sliks[k],median) == -1){
			System.out.print("n");
			for (int i=0;i<indicators.size();i++){
			    coin = Math.random();
			    if (coin>0.5)
				indicators.elementAt(i).setSampleVal(k,true);
			    else
				indicators.elementAt(i).setSampleVal(k,false);
			}
		    }
		    else
			System.out.print("o");
		}
	    }
	    if  (samplemode==4){
		double[] oldsamplelik;
		double[] newsamplelik;
		double[] likthresh;
		double[][] likratios = new double[indicators.size()][2]; 
		double[][] likratiossorted;
		GradientGraphIndicatorNode ggin;
		for (int k=0;k<samplecount;k++){
		    oldsamplelik=llnode.getSampleLikelihood(k);
		    setTruthVals(k);
		    for (int i=0;i<indicators.size();i++){
			ggin = (GradientGraphIndicatorNode)indicators.elementAt(i);
			ggin.toggleCurrentInst();
			llnode.evaluate();
			ggin.toggleCurrentInst();
			newsamplelik=llnode.likelihood();
			likratios[i]=SmallDouble.divide(newsamplelik,oldsamplelik);
		    }
		    likratiossorted=likratios.clone();
		    Arrays.sort((Object[])likratiossorted,0,likratiossorted.length,new SmallDoubleArrayComparatorByComponent(0,1));
		    likthresh=likratiossorted[likratiossorted.length-likratiossorted.length/5-1];
		    for (int i=0;i<indicators.size();i++){
			if ( SmallDouble.compareSD(likratios[i],likthresh) == 1 )
			    ((GradientGraphIndicatorNode)indicators.elementAt(i)).toggleSampleVal(k);
		    }
		}
	    }
	    System.out.println();
	} /* if (size>0) */
	return !abort;
    }

    /** Sets the truthval fields in the ProbFormNodes corresponding
     * to unobserved atoms to the truthvalues in the sno's sample
     *
     * If sno<0 do nothing!
     */
    public void setTruthVals(int sno){
	if (sno >=0)
	    for (int i=0;i<indicators.size();i++){
		indicators.elementAt(i).setCurrentInst(sno);
	    }
    }


    public void showLikelihoodNode(RelStruc A){
	System.out.println("Likelihood" + llnode.value());
    }



    public void showAllNodes(int verbose,RelStruc A){
	if (verbose >0){
	    System.out.println("**** Node " + llnode.name(A));
	    if (llnode.value == null)
		System.out.println("**** Value null");
	    else
		System.out.println("**** Value " + llnode.value());
	    // System.out.println("**** Bounds " + llnode.lowerBound() + "," + llnode.upperBound());
	    System.out.println();
	}
	if (verbose >5){
	    Enumeration e = allNodes.elements();
	    GradientGraphNode nextggn;
	    while (e.hasMoreElements()){
		nextggn = (GradientGraphNode)e.nextElement();
		System.out.println("**** Node " + nextggn.name(A));
		if (nextggn.value == null)
		    System.out.println("**** Value null");
		else
		    System.out.println("**** Value " + nextggn.value());
		// System.out.println("**** Bounds " + nextggn.lowerBound() + "," + nextggn.upperBound());
		System.out.println();
	    }
	}
    }



    /** Returns lambda*firstpoint + (1-lambda)*secondpoint */
    private double[] midpoint(double[] firstpoint, double[] secondpoint, double lambda){
	double[] result = new double[firstpoint.length];
	for (int i=0;i<result.length;i++)
	    result[i]=lambda*firstpoint[i]+(1-lambda)*secondpoint[i];
	return result;
    }

    /** Determines the direction for the linesearch given a current theta 
     * and gradient
     */
    private double[] getDirection(double[] theta, double[] gradient){
	double[] result = new double[gradient.length];
	/* Penalize the gradient components that are leading towards the
	 * boundary of the parameter space:
	 */
	for (int i=0 ;i<result.length;i++){
	    if (gradient[i]<0)
		result[i]=gradient[i]*theta[i];
	    else
		result[i]=gradient[i]*(1-theta[i]);
	    // 	    result[i]=gradient[i]*Math.min(1-theta[i],theta[i]);
	}
	return result;
    }

    /** Searches for likelihood-optimizing parameters, starting at
     * currenttheta
     *
     * Returns the paramter vector found, to which is appended the 
     * likelihood value obtained by these parameters, represented 
     * as a double[2] array, as returned by currentLikelihood()
     */
    private double[] thetasearch(double[] currenttheta, 
				 double linesearchdistthreshold,
				 double linesearchlikthreshold,
				 int samplesize,
				 int maxfails,
				 int[] iterationcounters){
	double[] gradient;
	double[] oldthetas = currenttheta;
	double oldlikelihood[] = {0,0};
	double[] newlikelihood = new double[2];
	double lratio;
	boolean terminate = false;
	boolean success;
	int maxiterations = 30;
	int iterationcount = 0;
	long time;
	long nexttime;
	while (!terminate){
	    /* compute the gradient */
	    evaluateLikelihoodAndPartDerivs(false);
	    gradient =  llnode.gradientsumAsDouble();   

	    System.out.println("Gradient: " + rbnutilities.arrayToString(gradient));

	    /* Linesearch in direction of gradient */
	    time = System.currentTimeMillis();

	    /****************************************
	     * call linesearch
	     ****************************************/
	    currenttheta = linesearch(currenttheta,getDirection(currenttheta,gradient),
				      linesearchdistthreshold,
				      linesearchlikthreshold,
				      iterationcounters);
	    nexttime = System.currentTimeMillis();
	    
	    setParameters(currenttheta);
	    evaluateLikelihoodAndPartDerivs(true);
	    newlikelihood = llnode.likelihoodsum();
 	    System.out.println("currenttheta: " + rbnutilities.arrayToString(currenttheta));
 	    System.out.println("New likelihood: " + rbnutilities.arrayToString(newlikelihood));
	    

	    lratio = SmallDouble.toStandardDouble(SmallDouble.divide(newlikelihood,oldlikelihood));

	    /* Sample new indicators and evaluate likelihood  */
	    success=false;
	    while (!success){	    
		if (sampleIndicators(samplesize,maxfails,4))
		    success = true;
	    }

	    if (MyMathOps.euclDist(oldthetas,currenttheta) < linesearchdistthreshold ||
		iterationcount > maxiterations)
		// 	    if (iterationcount > 100 || lratio < likelihoodthreshold)
		// 	    if (iterationcount > 100 || likelihoodRatio(newlikelihood,oldlikelihood)<likelihoodthreshold)	    
		terminate = true;
	    iterationcount++;
	    oldlikelihood = newlikelihood;
	    oldthetas = currenttheta;
	    iterationcounters[0]++;
	}
	double[] result = new double[currenttheta.length+3];
	for (int i=0;i<currenttheta.length;i++)
	    result[i]=currenttheta[i];
	result[currenttheta.length]=newlikelihood[0];
	result[currenttheta.length+1]=newlikelihood[1];	
	
	result[currenttheta.length+2]=SmallDouble.nthRoot(newlikelihood,llnode.numChildren());
	return result;
    }

    /** timers[2]: time spent on linesearch
     *  timers[3]: time spent on computing gradient
     */
    public double[][] learnParameters(double[] trueparameters,
				      int[] iterationcounters)
    {
	int restarts = 15;
	double linesearchdistthreshold = 10E-3;
	double linesearchlikthreshold = 10E-3;

	
	int[] samplesize = null;
	if (indicators.size()>0){
	    int thesesizes[] = {30};
	    samplesize = thesesizes;
	}
	else{
	    samplesize = new int[1];
	    samplesize[0]=0;
	}



       
	/* Rows in resultArray correspond to restarts of the learning 
	 * procedure from random initial parameters.
	 * Columns are as follows: 
	 * resultArray[0:paramNodes.size()-1] : the parameter values learned in the
	 *                                      order given by paramNodes
	 * resultArray[paramNodes.size():paramNodes.size()+1]: the likelihood value for
	 *                                                     the parameters represented as a small double.
	 *                                                     When data is incomplete, then this likelihood is with
	 *                                                     respect to the last sample.
	 * resultArray[paramNodes.size()+2]: the arithmetic mean of the likelihoodfactors contributed 
	 *                                   by the children of llnode.
	 * resultArray[paramNodes.size()+3]: the distance of the learned parameters to the true parameters
	 * resultArray[paramNodes.size()+4]: the samplesize used 
	 * resultArray[paramNodes.size()+5]: time for learning
	 */
	double[][] resultArray = new double[samplesize.length*restarts+1][paramNodes.size()+6];
	double[] lastthetas;
	double distance;
	long time;

	for (int i=0;i<samplesize.length;i++){
	    for (int j=0;j<restarts;j++){
		/* First find an initial setting of the parameters and an 
		 * initial sample, such that at least a proportion of
		 * sampleSuccessRate samples were not aborted
		 */
		int maxfails = 5*samplesize[i];
		boolean success = false;
		success = false;
		while (!success){
		    setParametersRandom();
		    //setParametersUniform();
		    System.out.println("samplesize " + samplesize[i]);
		    //System.out.println("trying parameters " + rbnutilities.arrayToString(currentParameters()));
		    if (sampleIndicators(samplesize[i],maxfails,0))
			success = true;
		}
		double[] currenttheta = currentParameters();

		/************************************************
		 *
		 *  call thetasearch 
		 *
		 ************************************************/
		time = System.currentTimeMillis();
		lastthetas =thetasearch(currenttheta,linesearchdistthreshold,
					linesearchlikthreshold,samplesize[i],maxfails,iterationcounters);

		for (int k=0;k<lastthetas.length;k++)
		    resultArray[i*restarts+j][k]=lastthetas[k];
		distance=0;
		for (int k=0;k<trueparameters.length;k++)
		    distance = distance+Math.abs(trueparameters[k]-resultArray[i*restarts+j][k]);
		distance = distance/trueparameters.length;
		resultArray[i*restarts+j][paramNodes.size()+3]=distance;
		resultArray[i*restarts+j][paramNodes.size()+4]=samplesize[i];
		resultArray[i*restarts+j][paramNodes.size()+5]=System.currentTimeMillis()-time;
	    } /* for restarts ... */
	} /* for samplesize ...*/
		   
	setParameters(trueparameters);
	evaluateLikelihoodAndPartDerivs(true);

	// 	for (int j=0;j<trueparameters.length;j++)
	// 	    resultArray[restarts][j]=trueparameters[j];
	// 	resultArray[restarts][trueparameters.length]=currentLikelihood()[0];
	// 	resultArray[restarts][trueparameters.length+1]=currentLikelihood()[1];
	// 	resultArray[restarts][trueparameters.length+2]=SmallDouble.nthRoot(currentLikelihood(),llnode.numChildren());
	// 	resultArray[restarts][trueparameters.length+3]=0.0;
	// 	resultArray[restarts][trueparameters.length+3]=0;

	for (int j=0;j<trueparameters.length;j++)
	    resultArray[samplesize.length*restarts][j]=trueparameters[j];
	resultArray[samplesize.length*restarts][trueparameters.length]=currentLikelihood()[0];
	resultArray[samplesize.length*restarts][trueparameters.length+1]=currentLikelihood()[1];
	resultArray[samplesize.length*restarts][trueparameters.length+2]=SmallDouble.nthRoot(currentLikelihood(),llnode.numChildren());
	resultArray[samplesize.length*restarts][trueparameters.length+3]=0.0;
	resultArray[samplesize.length*restarts][trueparameters.length+4]=0.0;
	resultArray[samplesize.length*restarts][trueparameters.length+4]=0.0;

	/* Sort results by increasing likelihoodscore */
	Arrays.sort((Object[])resultArray, 0,restarts,new SmallDoubleArrayComparatorByComponent(paramNodes.size(),paramNodes.size()+1));
	return resultArray;
    }
    


    /** Performs a linesearch for parameter settings optimizing 
     * log-likelihood starting from oldthetas in the direction
     * gradient
     */
    private double[] linesearch(double[] oldthetas, double[] gradient, 
				double distthreshold, double likthreshold,
				int[] iterationcounters){
	double[] leftbound=oldthetas;
	double[] rightbound = new double[oldthetas.length];
	double[] middle1 = new double[oldthetas.length];
	double[] middle2 = new double[oldthetas.length];
	

	double[] leftvalue;
	double[] rightvalue;
	double[] middlevalue1;
	double[] middlevalue2;

	double lratio;

	/* First find the point where the line oldthetas+lambda*gradient intersects
	 * the boundary of the parameter space
	 */
	double lambda = Double.POSITIVE_INFINITY;
	for (int i=0;i<oldthetas.length;i++){
	    if (gradient[i]<0)
		lambda = Math.min(lambda,-oldthetas[i]/gradient[i]);
	    if (gradient[i]>=0)
		lambda = Math.min(lambda,(1-oldthetas[i])/gradient[i]);
	}
	for (int i=0;i<oldthetas.length;i++)
	    rightbound[i]= oldthetas[i]+lambda*gradient[i];
	
	/** Initialize the search. The first 2 lines are redundant 
	 * if llnode.likelihoodsum holds the correct value for oldthetas
	 */
	setParameters(oldthetas);
	evaluateLikelihoodAndPartDerivs(true);
	leftvalue = llnode.likelihood();

	/** The following can easily result in rightvalue = NaN or -infinity!*/
	setParameters(rightbound);
	evaluateLikelihoodAndPartDerivs(true);
	rightvalue = llnode.likelihood();
	boolean terminate = false;
	while (!terminate){
	    System.out.print("+");
	    //System.out.println("left bound: " + rbnutilities.arrayToString(leftbound) + "/" + leftvalue +
	    //		       "  right bound: " + rbnutilities.arrayToString(rightbound)+ "/" + rightvalue );
	    // 	    System.out.println("left ll: "   + rbnutilities.arrayToString(leftvalue) +
	    // 	    		       "  right ll: "  + rbnutilities.arrayToString(rightvalue) );
	    middle1 = midpoint(leftbound,rightbound,0.75);
	    middle2 = midpoint(leftbound,rightbound,0.25);

	    
	    setParameters(middle1);
	    evaluateLikelihoodAndPartDerivs(true);
	    middlevalue1=llnode.likelihood();
	    
	    setParameters(middle2);
	    evaluateLikelihoodAndPartDerivs(true);
	    middlevalue2=llnode.likelihood();
	    
	    //System.out.println("middle1: " + rbnutilities.arrayToString(middle1)+ "/" + rbnutilities.arrayToString(middlevalue1) +
	    //		       " middle2: " + rbnutilities.arrayToString(middle2)+ "/" + rbnutilities.arrayToString(middlevalue2) );
	    // 	    	    System.out.println("middle1: "  + rbnutilities.arrayToString(middlevalue1) +
	    // 	     	    		       " middle2: "  + rbnutilities.arrayToString(middlevalue2) );
	    if (compareLikelihood(middlevalue1,middlevalue2)){
		rightbound = middle2;
		rightvalue = middlevalue2;
	    }
	    else{
		leftbound = middle1;
		leftvalue = middlevalue1;
	    }
	    
	    //lratio=likelihoodRatio(leftvalue,rightvalue);
	    lratio = SmallDouble.toStandardDouble(SmallDouble.divide(leftvalue,rightvalue));
	    //System.out.println("Dist: " + MyMathOps.euclDist(rightbound,leftbound) +
	    //		       "  Lik: " + lratio);
	    if (MyMathOps.euclDist(rightbound,leftbound) < distthreshold)
		terminate = true;
	    
	    if (lratio < 1+likthreshold && lratio > 1-likthreshold)
		terminate = true;
	    iterationcounters[1]++;
	}
	System.out.println();
	double[] returnval = midpoint(leftbound,rightbound,0.5);
	setParameters(returnval);
	evaluateLikelihoodAndPartDerivs(true);
	// 	System.out.println("Returnvalue:  " + rbnutilities.arrayToString(returnval));
	// 	System.out.println("Likelihood at return value: " + rbnutilities.arrayToString(llnode.likelihood));
	return midpoint(leftbound,rightbound,0.5);
    }

    /** Sets the parameter values to thetas. thetas[i] will be the
     * value of the parameter in the i'th position in this.paramNodes
     */
    public void setParameters(double[] thetas){
	if (thetas.length != paramNodes.size())
	    System.out.println("Size mismatch in GradientGraph.setParameters!");
	for (int i=0;i<thetas.length;i++)
	    if (paramNodes.elementAt(i)!=null)
		paramNodes.elementAt(i).setCurrentParamVal(thetas[i]);
    }

    public double[] getParameters(){
	double[] result = new double[paramNodes.size()];
	for (int i=0;i<paramNodes.size();i++)
	    result[i]=paramNodes.elementAt(i).getCurrentParamVal();
	return result;
    }


    public void setParametersRandom(){
	for (int i=0;i<paramNodes.size();i++)
	    if (paramNodes.elementAt(i)!=null)
		paramNodes.elementAt(i).setCurrentParamVal(Math.random());
    }

    public void setParametersUniform(){
	for (int i=0;i<paramNodes.size();i++)
	    if (paramNodes.elementAt(i)!=null)
		paramNodes.elementAt(i).setCurrentParamVal(0.5);
    }

  

    public String showGraphInfo(int verbose, RelStruc A){
	String result = "";
	result = result + "% Number of indicator nodes: " + indicators.size() +'\n';
	// 	result = result + "Parameter nodes: ";
	// 	for (int i=0;i<paramNodes.size();i++)
	// 	    System.out.print(paramNodes.elementAt(i).name()+ "  ");
	// 	result = result + ();
	// 	result = result + ("Parameter values: " + rbnutilities.arrayToString(currentParameters()));

	// 	result = result + ();
	result = result + "% Total number of nodes: " + allNodes.size() +'\n';
	result = result + "% Total number of links: " + numberOfEdges() +'\n';

	// 	showAllNodes(verbose,A);
	return result;
    }

    /** Prints a list of  likelihood values for all possible parameter settings
     * obtained by varying each parameter from 0.0 to 1.0 using a stepsize of incr
     */
    public void showAllLikelihoods(double incr){
	double[] nextsetting = new double[paramNodes.size()];
	for (int i=0;i<nextsetting.length;i++)
	    nextsetting[i] = 0.0;
	int nextindex = nextsetting.length - 1;
	double nextll;
	double max = 0;
	double[] best = nextsetting.clone();
	while (nextindex >= 0){
	    setParameters(nextsetting);
	    evaluateLikelihoodAndPartDerivs(true);
	    nextll = llnode.value();
	    if (nextll > max){
		max = nextll;
		best = nextsetting.clone();
	    }
	    //System.out.println(rbnutilities.arrayToString(nextsetting)+": " + nextll);
	    /* Find the next parameter setting */
	    nextindex = nextsetting.length - 1;
	    while (nextindex >= 0 && nextsetting[nextindex]>=0.9999)
		nextindex--;
	    if (nextindex >=0){
		nextsetting[nextindex]=nextsetting[nextindex]+incr;	
		for (int i=nextsetting.length - 1;i>nextindex;i--)
		    nextsetting[i]=0.0;
	    }
	}	   
	System.out.println("Best: " + rbnutilities.arrayToString(best)+": " + max);
    }

    private void unsetIndicators(){
	for (int i=0;i<indicators.size();i++)
	    indicators.elementAt(i).unset();	
    }


    /** Returns true if  l1 represents a larger or equal
     * likelihood than l2. 
     * Likelihoodvalues are given by l[0] * 1El[1]
     */
    private boolean compareLikelihood(double[] l1, double[] l2){
	// 	int power1 = Math.log(l1[0])/Math.log(10);
	// 	int power2 = Math.log(l2[0])/Math.log(10);
	// 	if (power1+l1[1]>power2+l2[1])
	// 	    return true;
	// 	if (power1+l1[1]<power2+l2[1])
	// 	    return false;
	// 	double decims1 = l1[0]/power1;
	// 	double decims2 = l2[0]/power2;
	// 	if (decims1>=decims2)
	// 	    return true;
	// 	else return false;
	if (likelihoodRatio(l1,l2)>=1)
	    return true;
	else
	    return false;
    }

    private double likelihoodRatio(double[] l1, double[] l2){
	// 	System.out.println("likelihoodRatio for " + rbnutilities.arrayToString(l1) + " " 
	// 			   + rbnutilities.arrayToString(l2));
	int power1 = (int)(Math.log(l1[0])/Math.log(10));
	int power2 = (int)(Math.log(l2[0])/Math.log(10));
	double decims1 = l1[0]/Math.pow(10,power1);
	double decims2 = l2[0]/Math.pow(10,power2);
	power1=power1-(int)l1[1];
	power2=power2-(int)l2[1];
	// 	System.out.println(power1+ " " + power2+ " " + decims1 + " " + decims2);
	// 	System.out.println((decims1/decims2)*Math.pow(10,power1-power2));
	return (decims1/decims2)*Math.pow(10,power1-power2);
	
    }


    /** Returns the number of nodes in the graph */
    public int numberOfNodes(){       
	return allNodes.size()+1;
    }

    /** Returns the number of indicator nodes in the graph */
    public int numberOfIndicators(){       
	return indicators.size();
    }


    /** Returns the number of links in the graph */
    public int numberOfEdges(){
	int result = llnode.childrenSize();
	Enumeration e = allNodes.elements();

	while (e.hasMoreElements())
	    result = result + ((GradientGraphNode)e.nextElement()).childrenSize();

	return result;
    }
}
